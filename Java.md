## 一. Java进程与线程
*转载自http://www.cnblogs.com/skywang12345/p/3479202.html*

#### 进程
> 一个程序进入内存运行，便成为一个进程。拥有自己独立的系统资源和地址空间，动态产生和消亡。

#### 线程
> 是进程中的一个实体，不拥有系统资源，但可与同属一个进程的其他线程共享进程的所有资源。
> java中主线程main是由Java虚拟机创建的，程序一启动就会自动运行。

#### 用户线程和守护线程
1. Thread.isDaemon(fale)是用户线程，Thread.isDaemon(true)是守护线程    
2. 默认是用户线程
3. Java虚拟机一旦启动，就会一直运行，直到:
> exit()方法被调用执行   
> 只有搜狐户线程在运行  

#### 线程的5种状态
1. 新建状态:
> 线程对象被新建后，就进入了新建状态，此时由java虚拟机分配了内存         

2. 就绪状态:
> 线程对象被调用了start()方法后，就处于就绪状态，也叫可执行状态，随时可以被CPU调度执行

3. 运行状态:
> 线程获取CPU权限进行执行，线程只能从就绪状态进入运行状态

4. 阻塞状态:
> 线程因为某种原因放弃CPU使用权，暂时停止运行。阻塞状态分为3种:
>- 等待阻塞：调用wait方法，让线程等待某工作的完成    
>- 同步阻塞：线程在调用synchronized获取同步锁时失败，因为锁被其他线程占用      
>- 其他阻塞：调用了线程的sleep(),join()或发出了I/O请求

5. 死亡状态:
> 线程执行完了或异常退出run方法，结束了生命周期

#### 实现多线程的两种方式
1. 继承Thread类(各子线程彼此独立) 
2. 实现Runnable接口(各子线程资源共享)

#### start()和run()区别
1. start()用于启动一个新线程，会调用响应的run方法，不能重复被调用       
2. run()和普通成员方法一样，可以重复被调用，当单独调用时，会在当前线程中执行，不会启动新线程   

#### synchronized关键字
1. 原理
> java中，每一个对象有且仅有一个同步锁，即同步锁是依赖于对象而存在。    
> 不同线程对同步锁的访问是互斥的。即同一时间点，对象的同步锁只能由一个线程获取到。     
> synchronized(this)指当前所在类的对象的同步锁，synchronized(obj)指“obj这个对象”的同步锁。

2. 基本规则
> 当一个线程访问“某对象”的“synchronized方法”或"synchronized代码块"时，其他线程对"该对象"的该"synchronized方法"或"synchronized代码块"的访问将被阻塞      
> 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问"该对象"的非同步代码块      
> 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对"该对象"的其他的"synchronized方法"或"synchronized代码块"的访问将被阻塞

3. “synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。  
4. 实例锁和全局锁
> 实例锁指的锁在一个实例对象上，对应的就是synchronized关键字       
> 全局锁指的锁在一个类上，对应的就是static synchronized关键字
> eg: Something有两个实例x 和 y, 以及四个方法
```java
01) x.isSyncA() 与 x.isSyncB() 

02) x.isSyncA() 与 y.isSyncA()

03) x.cSyncA() 与 y.cSyncB()

04) x.isSyncA() 与 Something.cSyncA()

/**
01: 不能被同时访问，因为2个方法都是访问同一个对象x的同步锁     
02: 可以同时被访问，因为访问的不是同一个对象的同步锁     
03: 不能同时被访问，因为2个方法都是static类型，相当于共用的都是Something类的同步锁     
04: 可以同时被访问，因为x.isSyncA()使用的是对象x的同步锁，而后者使用的是Something类的锁
*/
```

#### 等待与唤醒
*当前线程”是指正在cpu上运行的线程* 

1. wait()
> 让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的notify()或notifyAll()方法，方可被唤醒进入就绪状态

2. wait(long timeout)
> 让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的notify()或 notifyAll()，或者超过指定的时间量”，方可被唤醒(进入“就绪状态”)

3. notify()
> 唤醒在此对象监视器上等待的单个线程

4. notifyAll()
> 唤醒在此对象监视器上等待的所有线程

5. 
> wait()等待线程和notify()之间正是通过对象的同步锁关联起来的。而同步锁是对象持有的，这就是notify(), wait()等函数定义在Object类，而不是Thread类中的原因。

#### yield让步
> 使当前线程由运行状态变成就绪状态，从而让其他具有相同优先级的线程获取执行权     
> 但不能保证当前线程调用yield后，其他同优先级线程就一定能获得执行权，也可能是当前线程又进入运行状态      
> 不会释放同步锁
> 定义在Thread中      

#### sleep休眠
> 让当前线程由运行状态进入休眠阻塞状态，不会释放同步锁
> 定义在Thread中  

#### Join()
> 让主线程等待子线程结束之后才能继续运行
> 定义在Thread中

#### interrupt中断终止线程
> interrupt()除了返回中断标记外，还会清除中断标记   
> isInterrupted()只是返回中断标记  


## Java静态变量、方法、类

####静态变量和方法
1. 静态方法可以直接调用同类的静态变量，不能直接调用同类的非静态变量    
2. 静态方法调用同类的非静态变量，要先创建对象，再通过对象调用同类的非静态变量   
3. 普通成员方法可以直接调用同类的静态和非静态成员    
4. 静态方法不能直接调用非静态方法，需要通过对象调用   

#### 静态类
1. 一个类要被声明为static，只能是静态内部类   
2. 静态内部类只能访问外部类的静态成员变量和方法，不能访问非静态成员变量和方法   
3. 普通内部类可以方法外部类的任意成员变量和方法   
4. 静态内部类可以声明普通成员变量和方法，普通内部类不能声明静态成员变量和方法   
5. 静态内部类的初始化不需要外部类的实例
```java
Inner in = new Outer.Inner();
```
6. 普通内部类的初始化依赖于外部类的实例
```java
Outter out = new Outter();
Inner in = out.new Inner();
```