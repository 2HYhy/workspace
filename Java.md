## 一. 进程与线程
*转载自http://www.cnblogs.com/skywang12345/p/3479202.html*

#### 进程
> 一个程序进入内存运行，便成为一个进程。拥有自己独立的系统资源和地址空间，动态产生和消亡。

#### 线程
> 是进程中的一个实体，不拥有系统资源，但可与同属一个进程的其他线程共享进程的所有资源。
> java中主线程main是由Java虚拟机创建的，程序一启动就会自动运行。

## 二. Java多线程

#### 线程的5种状态
1. 新建状态:
> 线程对象被新建后，就进入了新建状态，此时由java虚拟机分配了内存         

2. 就绪状态:
> 线程对象被调用了start()方法后，就处于就绪状态，也叫可执行状态，随时可以被CPU调度执行

3. 运行状态:
> 线程获取CPU权限进行执行，线程只能从就绪状态进入运行状态

4. 阻塞状态:
> 线程因为某种原因放弃CPU使用权，暂时停止运行。阻塞状态分为3种:
>- 等待阻塞：调用wait方法，让线程等待某工作的完成    
>- 同步阻塞：线程在调用synchronized获取同步锁时失败，因为锁被其他线程占用      
>- 其他阻塞：调用了线程的sleep(),join()或发出了I/O请求

5. 死亡状态:
> 线程执行完了或异常退出run方法，结束了生命周期

#### 实现多线程的两种方式
1. 继承Thread类(各子线程彼此独立) 
2. 实现Runnable接口(各子线程资源共享)

#### start()和run()区别
1. start()用于启动一个新线程，会调用响应的run方法，不能重复被调用       
2. run()和普通成员方法一样，可以重复被调用，当单独调用时，会在当前线程中执行，不会启动新线程   

#### synchronized关键字
1. 原理
> java中，每一个对象有且仅有一个同步锁，即同步锁是依赖于对象而存在。    
> 不同线程对同步锁的访问是互斥的。即同一时间点，对象的同步锁只能由一个线程获取到。     
> synchronized(this)指当前所在类的对象的同步锁，synchronized(obj)指“obj这个对象”的同步锁。

2. 基本规则
> 当一个线程访问“某对象”的“synchronized方法”或"synchronized代码块"时，其他线程对"该对象"的该"synchronized方法"或"synchronized代码块"的访问将被阻塞      
> 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程仍然可以访问"该对象"的非同步代码块      
> 当一个线程访问“某对象”的“synchronized方法”或者“synchronized代码块”时，其他线程对"该对象"的其他的"synchronized方法"或"synchronized代码块"的访问将被阻塞

3. “synchronized方法”是用synchronized修饰方法，而 “synchronized代码块”则是用synchronized修饰代码块。  
4. 实例锁和全局锁
> 实例锁指的锁在一个实例对象上，对应的就是synchronized关键字       
> 全局锁指的锁在一个类上，对应的就是static synchronized关键字
> eg: Something有两个实例x 和 y, 以及四个方法
```java
01) x.isSyncA() 与 x.isSyncB() 

02) x.isSyncA() 与 y.isSyncA()

03) x.cSyncA() 与 y.cSyncB()

04) x.isSyncA() 与 Something.cSyncA()

/**
01: 不能被同时访问，因为2个方法都是访问同一个对象x的同步锁     
02: 可以同时被访问，因为访问的不是同一个对象的同步锁     
03: 不能同时被访问，因为2个方法都是static类型，相当于共用的都是Something类的同步锁     
04: 可以同时被访问，因为x.isSyncA()使用的是对象x的同步锁，而后者使用的是Something类的锁
*/
```

#### 等待与唤醒
*当前线程”是指正在cpu上运行的线程* 

1. wait()
> 让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的notify()或notifyAll()方法，方可被唤醒进入就绪状态

2. wait(long timeout)
> 让当前线程处于等待(阻塞)状态，直到其他线程调用此对象的notify()或 notifyAll()，或者超过指定的时间量”，方可被唤醒(进入“就绪状态”)

3. notify()
> 唤醒在此对象监视器上等待的单个线程

4. notifyAll()
> 唤醒在此对象监视器上等待的所有线程

5. 
> wait()等待线程和notify()之间正是通过对象的同步锁关联起来的。而同步锁是对象持有的，这就是notify(), wait()等函数定义在Object类，而不是Thread类中的原因。